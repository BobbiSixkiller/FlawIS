/* eslint-disable */
import * as types from './graphql';



/**
 * Map of all GraphQL operations in the project.
 *
 * This map has several performance disadvantages:
 * 1. It is not tree-shakeable, so it will include all operations in the project.
 * 2. It is not minifiable, so the string of a GraphQL query will be multiple times inside the bundle.
 * 3. It does not support dead code elimination, so it will add unused operations.
 *
 * Therefore it is highly recommended to use the babel or swc plugin for production.
 */
const documents = {
    "fragment Address on Address {\n  street\n  city\n  postal\n  country\n}\n\nfragment Billing on Billing {\n  name\n  address {\n    ...Address\n  }\n  ICO\n  ICDPH\n  DIC\n  stampUrl\n  variableSymbol\n  IBAN\n  SWIFT\n}\n\nfragment User on User {\n  id\n  name\n  email\n  organization\n  telephone\n  role\n  verified\n  createdAt\n  updatedAt\n  billings {\n    ...Billing\n  }\n}\n\nquery me {\n  me {\n    ...User\n  }\n}\n\nmutation login($email: String!, $password: String!) {\n  login(email: $email, password: $password) {\n    token\n  }\n}\n\nquery forgotPassword($email: String!) {\n  forgotPassword(email: $email)\n}\n\nmutation passwordReset($data: PasswordInput!) {\n  passwordReset(data: $data) {\n    message\n    data {\n      token\n    }\n  }\n}\n\nmutation register($data: RegisterInput!) {\n  register(data: $data) {\n    message\n    data {\n      token\n    }\n  }\n}\n\nmutation resendActivationLink {\n  resendActivationLink\n}\n\nmutation activateUser {\n  activateUser\n}": types.AddressFragmentDoc,
    "fragment Invoice on Invoice {\n  body {\n    body\n    comment\n    dueDate\n    issueDate\n    price\n    type\n    vat\n    vatDate\n  }\n  issuer {\n    ...Billing\n  }\n  payer {\n    ...Billing\n  }\n}\n\nquery conferences($after: ObjectId, $first: Int) {\n  conferences(after: $after, first: $first) {\n    edges {\n      cursor\n      node {\n        id\n        slug\n        translations {\n          sk {\n            name\n            logoUrl\n          }\n          en {\n            name\n            logoUrl\n          }\n        }\n        dates {\n          start\n          end\n        }\n        createdAt\n        updatedAt\n      }\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery conference($slug: String!) {\n  conference(slug: $slug) {\n    id\n    slug\n    translations {\n      sk {\n        name\n        logoUrl\n      }\n      en {\n        name\n        logoUrl\n      }\n    }\n    attending {\n      invoice {\n        ...Invoice\n      }\n    }\n  }\n}\n\nquery textSearchConference($text: String!) {\n  textSearchConference(text: $text) {\n    id\n    slug\n    translations {\n      sk {\n        name\n      }\n      en {\n        name\n      }\n    }\n  }\n}\n\nmutation createConference($data: ConferenceInput!) {\n  createConference(data: $data) {\n    message\n    data {\n      slug\n    }\n  }\n}\n\nmutation deleteConference($id: ObjectId!) {\n  deleteConference(id: $id)\n}": types.InvoiceFragmentDoc,
    "query users($after: ObjectId, $first: Int) {\n  users(after: $after, first: $first) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        email\n        organization\n        verified\n        role\n        createdAt\n        updatedAt\n      }\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery user($id: ObjectId!) {\n  user(id: $id) {\n    ...User\n  }\n}\n\nquery textSearchUser($text: String!) {\n  textSearchUser(text: $text) {\n    id\n    name\n    email\n  }\n}\n\nmutation updateUser($id: ObjectId!, $data: UserInput!) {\n  updateUser(id: $id, data: $data) {\n    message\n  }\n}\n\nmutation toggleVerifiedUser($id: ObjectId!) {\n  toggleVerifiedUser(id: $id) {\n    message\n  }\n}\n\nmutation deleteUser($id: ObjectId!) {\n  deleteUser(id: $id)\n}": types.UsersDocument,
};

/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment Address on Address {\n  street\n  city\n  postal\n  country\n}\n\nfragment Billing on Billing {\n  name\n  address {\n    ...Address\n  }\n  ICO\n  ICDPH\n  DIC\n  stampUrl\n  variableSymbol\n  IBAN\n  SWIFT\n}\n\nfragment User on User {\n  id\n  name\n  email\n  organization\n  telephone\n  role\n  verified\n  createdAt\n  updatedAt\n  billings {\n    ...Billing\n  }\n}\n\nquery me {\n  me {\n    ...User\n  }\n}\n\nmutation login($email: String!, $password: String!) {\n  login(email: $email, password: $password) {\n    token\n  }\n}\n\nquery forgotPassword($email: String!) {\n  forgotPassword(email: $email)\n}\n\nmutation passwordReset($data: PasswordInput!) {\n  passwordReset(data: $data) {\n    message\n    data {\n      token\n    }\n  }\n}\n\nmutation register($data: RegisterInput!) {\n  register(data: $data) {\n    message\n    data {\n      token\n    }\n  }\n}\n\nmutation resendActivationLink {\n  resendActivationLink\n}\n\nmutation activateUser {\n  activateUser\n}"): typeof import('./graphql').AddressFragmentDoc;
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "fragment Invoice on Invoice {\n  body {\n    body\n    comment\n    dueDate\n    issueDate\n    price\n    type\n    vat\n    vatDate\n  }\n  issuer {\n    ...Billing\n  }\n  payer {\n    ...Billing\n  }\n}\n\nquery conferences($after: ObjectId, $first: Int) {\n  conferences(after: $after, first: $first) {\n    edges {\n      cursor\n      node {\n        id\n        slug\n        translations {\n          sk {\n            name\n            logoUrl\n          }\n          en {\n            name\n            logoUrl\n          }\n        }\n        dates {\n          start\n          end\n        }\n        createdAt\n        updatedAt\n      }\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery conference($slug: String!) {\n  conference(slug: $slug) {\n    id\n    slug\n    translations {\n      sk {\n        name\n        logoUrl\n      }\n      en {\n        name\n        logoUrl\n      }\n    }\n    attending {\n      invoice {\n        ...Invoice\n      }\n    }\n  }\n}\n\nquery textSearchConference($text: String!) {\n  textSearchConference(text: $text) {\n    id\n    slug\n    translations {\n      sk {\n        name\n      }\n      en {\n        name\n      }\n    }\n  }\n}\n\nmutation createConference($data: ConferenceInput!) {\n  createConference(data: $data) {\n    message\n    data {\n      slug\n    }\n  }\n}\n\nmutation deleteConference($id: ObjectId!) {\n  deleteConference(id: $id)\n}"): typeof import('./graphql').InvoiceFragmentDoc;
/**
 * The graphql function is used to parse GraphQL queries into a document that can be used by GraphQL clients.
 */
export function graphql(source: "query users($after: ObjectId, $first: Int) {\n  users(after: $after, first: $first) {\n    edges {\n      cursor\n      node {\n        id\n        name\n        email\n        organization\n        verified\n        role\n        createdAt\n        updatedAt\n      }\n    }\n    pageInfo {\n      endCursor\n      hasNextPage\n    }\n  }\n}\n\nquery user($id: ObjectId!) {\n  user(id: $id) {\n    ...User\n  }\n}\n\nquery textSearchUser($text: String!) {\n  textSearchUser(text: $text) {\n    id\n    name\n    email\n  }\n}\n\nmutation updateUser($id: ObjectId!, $data: UserInput!) {\n  updateUser(id: $id, data: $data) {\n    message\n  }\n}\n\nmutation toggleVerifiedUser($id: ObjectId!) {\n  toggleVerifiedUser(id: $id) {\n    message\n  }\n}\n\nmutation deleteUser($id: ObjectId!) {\n  deleteUser(id: $id)\n}"): typeof import('./graphql').UsersDocument;


export function graphql(source: string) {
  return (documents as any)[source] ?? {};
}
